/**
 * @file image_compressor.cpp
 * @brief A collection of utility functions for loading, processing, and encoding images.
 *
 * This file provides a complete pipeline for image manipulation, including:
 * - Loading an image from a file path.
 * - Reading EXIF orientation data to correctly rotate/flip the image.
 * - Resizing the image to fit within specified maximum dimensions while preserving aspect ratio.
 * - Compressing the image into the JPEG format with a given quality.
 * - Encoding the final JPEG data into a Base64 string.
 *
 * It is designed to be called from other languages (e.g., via FFI), providing a C-style interface
 * with `image_compressor_from_path` as the main entry point and `image_compressor_free_string`
 * for memory management.
 *
 * @dependencies
 * - stb_image.h: for loading images.
 * - stb_image_write.h: for writing/compressing images to JPEG.
 * - stb_image_resize2.h: for high-quality image resizing.
 */
#include "image_compressor.h"
#include <cstring>
#include <vector>
#include <cstdlib> // malloc, free

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

#define STB_IMAGE_RESIZE2_IMPLEMENTATION
#include "stb_image_resize2.h"


/**
 * @brief Encodes a block of binary data into a Base64 string.
 *
 * @param bytes_to_encode Pointer to the input data (unsigned char array).
 * @param in_len The length of the input data in bytes.
 * @return A std::string containing the Base64 encoded result.
 */
static const char base64_chars[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789+/";

/**
 * Encodes a byte array into a Base64 string.
 * 
 * @param bytes_to_encode Pointer to data to encode.
 * @param in_len Length of the data.
 * @return Base64 encoded string.
 */
static std::string base64_encode(const unsigned char* bytes_to_encode, size_t in_len) {
    std::string ret;
    int i = 0;
    unsigned char char_array_3[3], char_array_4[4];

    while (in_len--) {
        char_array_3[i++] = *(bytes_to_encode++);
        if (i == 3) {
            char_array_4[0] =  (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +
                              ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +
                              ((char_array_3[2] & 0xc0) >> 6);
            char_array_4[3] =   char_array_3[2] & 0x3f;

            for (i = 0; i < 4; i++)
                ret += base64_chars[char_array_4[i]];
            i = 0;
        }
    }

    if (i > 0) {
        for (int j = i; j < 3; j++)
            char_array_3[j] = '\0';

        char_array_4[0] =  (char_array_3[0] & 0xfc) >> 2;
        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +
                          ((char_array_3[1] & 0xf0) >> 4);
        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +
                          ((char_array_3[2] & 0xc0) >> 6);
        char_array_4[3] =   char_array_3[2] & 0x3f;

        for (int j = 0; j < i + 1; j++)
            ret += base64_chars[char_array_4[j]];

        while ((i++ < 3))
            ret += '=';
    }

    return ret;
}


// --- Image Library Callbacks and Wrappers ---

/**
 * @brief A callback function for stbi_write_jpg_to_func.
 *
 * This function appends the JPEG data generated by `stb_image_write`
 * into a std::vector<unsigned char>.
 *
 * @param context A void pointer to a std::vector<unsigned char> where data will be stored.
 * @param data A void pointer to the chunk of JPEG data to write.
 * @param size The size of the data chunk in bytes.
 */
static void write_jpg_to_vector(void* context, void* data, int size) {
    auto* buffer = reinterpret_cast<std::vector<unsigned char>*>(context);
    buffer->insert(buffer->end(), (unsigned char*)data, (unsigned char*)data + size);
}

/**
 * @brief Resizes an image using the stb_image_resize2 library.
 *
 * @param input Pointer to the source raw image data.
 * @param input_w Width of the source image.
 * @param input_h Height of the source image.
 * @param channels Number of color channels in the image (e.g., 3 for RGB, 4 for RGBA).
 * @param output A reference to the vector that will store the resized image data.
 * @param output_w Target width for the resized image.
 * @param output_h Target height for the resized image.
 * @return true if resizing was successful, false otherwise.
 */
static bool resize_image(
    const unsigned char* input,
    int input_w, int input_h, int channels,
    std::vector<unsigned char>& output,
    int output_w, int output_h
) {
    output.resize(output_w * output_h * channels);

    stbir_pixel_layout layout;
    if (channels == 1) layout = STBIR_1CHANNEL;
    else if (channels == 2) layout = STBIR_2CHANNEL;
    else if (channels == 3) layout = STBIR_RGB;
    else if (channels == 4) layout = STBIR_RGBA;
    else return false;

    unsigned char* result = stbir_resize_uint8_srgb(
        input,
        input_w,
        input_h,
        0,
        output.data(),
        output_w,
        output_h,
        0,
        layout
    );

    return result != nullptr;
}


/**
 * @brief Compresses raw image data into a JPEG format and stores it in a buffer.
 *
 * @param image_data Pointer to the raw image data to compress.
 * @param width Width of the image.
 * @param height Height of the image.
 * @param channels Number of color channels.
 * @param quality The JPEG compression quality (1-100).
 * @param buffer A reference to the vector that will store the compressed JPEG data.
 * @return true if compression was successful, false otherwise.
 */
static bool compress_to_jpeg_buffer(
    const unsigned char* image_data,
    int width, int height, int channels, int quality,
    std::vector<unsigned char>& buffer
) {
    return stbi_write_jpg_to_func(write_jpg_to_vector, &buffer, width, height, channels, image_data, quality) != 0;
}


// --- EXIF and Image Transformations ---

/**
 * @brief Reads the EXIF orientation tag from a JPEG file.
 *
 * This function parses the JPEG file structure to find the APP1 segment
 * containing EXIF data and extracts the orientation value.
 *
 * @param filename The path to the JPEG file.
 * @return The orientation value (1-8) if found, otherwise returns 1 (normal orientation).
 */
static int read_exif_orientation(const char* filename) {
    FILE* f = fopen(filename, "rb");
    if (!f) return 1;

    uint8_t marker[2];
    fread(marker, 1, 2, f);
    if (marker[0] != 0xFF || marker[1] != 0xD8) {
        fclose(f);
        return 1;
    }

    while (!feof(f)) {
        if (fread(marker, 1, 2, f) != 2) break;
        if (marker[0] != 0xFF) break;

        uint8_t segment_type = marker[1];
        uint8_t size_buf[2];
        if (fread(size_buf, 1, 2, f) != 2) break;
        uint16_t segment_size = (size_buf[0] << 8) | size_buf[1];
        if (segment_size < 2) break;

        if (segment_type == 0xE1) { // APP1 (EXIF)
            uint8_t* data = (uint8_t*)malloc(segment_size - 2);
            fread(data, 1, segment_size - 2, f);
            if (memcmp(data, "Exif\0\0", 6) == 0) {
                uint8_t* tiff = data + 6;
                bool is_be = false;
                if (memcmp(tiff, "MM", 2) == 0) is_be = true;
                else if (memcmp(tiff, "II", 2) == 0) is_be = false;
                else {
                    free(data);
                    fclose(f);
                    return 1;
                }
                auto read16 = [&](const uint8_t* p) -> uint16_t {
                    if (is_be) return (p[0] << 8) | p[1];
                    else return p[0] | (p[1] << 8);
                };
                auto read32 = [&](const uint8_t* p) -> uint32_t {
                    if (is_be) return (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
                    else return p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
                };
                uint32_t ifd0_offset = read32(tiff + 4);
                if (ifd0_offset > segment_size - 6 - 4) {
                    free(data);
                    fclose(f);
                    return 1;
                }
                uint8_t* ifd0 = tiff + ifd0_offset;
                uint16_t entries = read16(ifd0);
                uint8_t* entry_ptr = ifd0 + 2;
                for (int i=0; i < entries; i++) {
                    uint16_t tag = read16(entry_ptr);
                    if (tag == 0x0112) { // Orientation tag
                        uint16_t format = read16(entry_ptr + 2);
                        uint32_t components = read32(entry_ptr + 4);
                        uint8_t* value_ptr = entry_ptr + 8;
                        uint16_t orientation = 0;
                        if (format == 3 && components == 1) {
                            orientation = read16(value_ptr);
                            free(data);
                            fclose(f);
                            if (orientation >= 1 && orientation <= 8)
                                return orientation;
                            else
                                return 1;
                        }
                    }
                    entry_ptr += 12;
                }
            }
            free(data);
            break;
        } else {
            fseek(f, segment_size - 2, SEEK_CUR);
        }
    }
    fclose(f);
    return 1;
}

/**
 * @brief Rotates an image 90 degrees clockwise.
 *
 * @param src Pointer to the source image data.
 * @param dst Pointer to the destination buffer for the rotated image.
 * @param width Width of the source image.
 * @param height Height of the source image.
 * @param channels Number of color channels.
 */
static void rotate90(const unsigned char* src, unsigned char* dst, int width, int height, int channels) {
    for (int y=0; y < height; y++) {
        for (int x=0; x < width; x++) {
            for (int c=0; c < channels; c++) {
                dst[(x * height + (height - y - 1)) * channels + c] = src[(y * width + x) * channels + c];
            }
        }
    }
}


/**
 * @brief Rotates an image 180 degrees.
 *
 * @param src Pointer to the source image data.
 * @param dst Pointer to the destination buffer for the rotated image.
 * @param width Width of the source image.
 * @param height Height of the source image.
 * @param channels Number of color channels.
 */
static void rotate180(const unsigned char* src, unsigned char* dst, int width, int height, int channels) {
    int size = width * height * channels;
    for (int i=0; i < size; i++) {
        dst[i] = src[size - i - 1];
    }
}


/**
 * @brief Rotates an image 270 degrees clockwise.
 *
 * @param src Pointer to the source image data.
 * @param dst Pointer to the destination buffer for the rotated image.
 * @param width Width of the source image.
 * @param height Height of the source image.
 * @param channels Number of color channels.
 */
static void rotate270(const unsigned char* src, unsigned char* dst, int width, int height, int channels) {
    for (int y=0; y < height; y++) {
        for (int x=0; x < width; x++) {
            for (int c=0; c < channels; c++) {
                dst[((width - x - 1) * height + y) * channels + c] = src[(y * width + x) * channels + c];
            }
        }
    }
}


/**
 * @brief Flips an image horizontally.
 *
 * @param src Pointer to the source image data.
 * @param dst Pointer to the destination buffer for the flipped image.
 * @param width Width of the source image.
 * @param height Height of the source image.
 * @param channels Number of color channels.
 */
static void flip_horizontal(const unsigned char* src, unsigned char* dst, int width, int height, int channels) {
    for (int y=0; y < height; y++) {
        for (int x=0; x < width; x++) {
            for (int c=0; c < channels; c++) {
                dst[(y * width + (width - x -1)) * channels + c] = src[(y * width + x) * channels + c];
            }
        }
    }
}

/**
 * @brief Calculates new dimensions for an image to fit within a bounding box while maintaining its aspect ratio.
 *
 * This function determines the correct scaling factor to ensure the original dimensions
 * (`original_w`, `original_h`) can fit inside the maximum dimensions (`max_w`, `max_h`)
 * without distortion. The image is only scaled down; it will not be enlarged if it's
 * already smaller than the bounding box.
 *
 * @param original_w The original width of the image.
 * @param original_h The original height of the image.
 * @param max_w The maximum allowed width of the bounding box.
 * @param max_h The maximum allowed height of the bounding box.
 * @param out_w An output parameter (passed by reference) that will be set to the new calculated width.
 * @param out_h An output parameter (passed by reference) that will be set to the new calculated height.
 */
static void fit_inside_box(int original_w, int original_h, int max_w, int max_h, int& out_w, int& out_h) {
    float ratio_w = (float)max_w / original_w;
    float ratio_h = (float)max_h / original_h;
    float ratio = (ratio_w < ratio_h) ? ratio_w : ratio_h;

    if (ratio >= 1.0f) {
        out_w = original_w;
        out_h = original_h;
    } else {
        out_w = (int)(original_w * ratio);
        out_h = (int)(original_h * ratio);
    }
}

// --- Public C-Style API ---

/**
 * @brief Main function to load, process, and compress an image from a file path.
 *
 * This function performs the following steps:
 * 1. Loads an image from the given path.
 * 2. Reads its EXIF orientation tag and applies the correct rotation/flip.
 * 3. Resizes the image to fit within `max_width` and `max_height`, preserving aspect ratio.
 * 4. Compresses the resulting image to JPEG format with the specified quality.
 * 5. Encodes the final JPEG data as a Base64 string.
 *
 * @param path The file path of the source image.
 * @param quality The desired JPEG compression quality (1-100).
 * @param max_width The maximum allowed width for the output image. If 0, width is not constrained.
 * @param max_height The maximum allowed height for the output image. If 0, height is not constrained.
 * @return A pointer to a heap-allocated C-string containing the Base64 encoded image.
 * Returns nullptr on failure. The caller is responsible for freeing this memory
 * using `image_compressor_free_string`.
 */
extern "C" char* image_compressor_from_path(const char* path, int quality, int max_width, int max_height) {
    if (!path) return nullptr;

    if (quality < 1) quality = 1;
    if (quality > 100) quality = 100;

    int width, height, channels;
    unsigned char* img = stbi_load(path, &width, &height, &channels, 0);
    if (!img) return nullptr;

    int orientation = read_exif_orientation(path);

    std::vector<unsigned char> rotated_image;
    const unsigned char* img_to_use = img;
    int w = width, h = height;

    if (orientation != 1) {
        switch (orientation) {
            case 2:
                rotated_image.resize(width * height * channels);
                flip_horizontal(img, rotated_image.data(), width, height, channels);
                img_to_use = rotated_image.data();
                break;
            case 3:
                rotated_image.resize(width * height * channels);
                rotate180(img, rotated_image.data(), width, height, channels);
                img_to_use = rotated_image.data();
                break;
            case 6:
                rotated_image.resize(width * height * channels);
                rotate90(img, rotated_image.data(), width, height, channels);
                std::swap(w, h);
                img_to_use = rotated_image.data();
                break;
            case 8:
                rotated_image.resize(width * height * channels);
                rotate270(img, rotated_image.data(), width, height, channels);
                std::swap(w, h);
                img_to_use = rotated_image.data();
                break;
            default:
                break;
        }
    }

    int new_w = w;
    int new_h = h;

    int limit_w = (max_width > 0) ? max_width : new_w;
    int limit_h = (max_height > 0) ? max_height : new_h;

    float scale_w = (float)limit_w / new_w;
    float scale_h = (float)limit_h / new_h;
    float scale = (scale_w < scale_h) ? scale_w : scale_h;

    if (scale < 1.0f) {
        new_w = (int)(new_w * scale);
        new_h = (int)(new_h * scale);
    }

    std::vector<unsigned char> resized_image;

    if (new_w != w || new_h != h) {
        if (!resize_image(img_to_use, w, h, channels, resized_image, new_w, new_h)) {
            stbi_image_free(img);
            return nullptr;
        }
        img_to_use = resized_image.data();
        w = new_w;
        h = new_h;
    }

    std::vector<unsigned char> jpeg_buffer;
    bool success = compress_to_jpeg_buffer(img_to_use, w, h, channels, quality, jpeg_buffer);
    stbi_image_free(img);
    if (!success) return nullptr;

    std::string base64 = base64_encode(jpeg_buffer.data(), jpeg_buffer.size());
    char* result = (char*)malloc(base64.size() + 1);
    if (!result) return nullptr;

    std::memcpy(result, base64.c_str(), base64.size());
    result[base64.size()] = '\0';

    return result;
}


/**
 * @brief Frees the memory allocated for the string returned by `image_compressor_from_path`.
 *
 * @param ptr A pointer to the C-string that needs to be freed.
 */
extern "C" void image_compressor_free_string(char* ptr) {
    free(ptr);
}
